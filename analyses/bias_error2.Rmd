---
title: "bias_error2"
author: "Devin Gamble"
date: "8/24/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Additional analyses on the effect of coordinate uncertainty (error distance) on pheno-climatic models  

*TO-DO*  
- Increase Bootstrap Rs 
- Bootstrap resampling for *Error D as covariate*?  
- Evaluate resampling from full models (all covariates)  

```{r echo = FALSE, message = FALSE, warning = FALSE}
#Load Packages
library(car)
library(tidyverse)
library(here)
library(ggplot2)
library(visreg)
library(jtools)
library(interactions)
library(kableExtra)
library(stringr)
```


#### Load Data  
```{r message = FALSE, warning = FALSE}
nemo_df2 <- read_csv(here::here("data_cleaning", "nemo_full_1901_2019.csv")) %>%  
  mutate(error_bin = as_factor(error_bin)) #Should this be ordered? #Combined specimen & climate data from 1901-2019
#1677 obs, 1251 columns

nemo_df1 <- read_csv(here::here("data_cleaning", "nemo_full_1861_2019.csv")) #Combined data for all years
#1764 obs, 1251 columns

options(contrasts = c("contr.sum", "contr.poly"))
```

Data subset by error distances/bins  
```{r message = FALSE, warning = FALSE}
#All errors
nemo_all_errors <- nemo_df2 %>% 
  filter(!is.na(error_dist_m)) 
#1239 out of 1764 obs with error distance
#1166 after rm records before 1901

#0-5 km resolution
nemo_e0_5 <- nemo_all_errors %>% 
  filter(error_bin == "<2 km" | error_bin == "2-5 km") 

#0-4 km - not used here
nemo_e0_4 <-  nemo_all_errors %>% 
  filter(error_dist_m >= 0 & error_dist_m <= 4000) #Do Not include error_bin in models

#0-2 km
nemo_e2 <- nemo_all_errors %>% 
  filter(error_bin == "<2 km") 

```

Smallest sample size is N = 743 in 0-2 km data subset. Randomly sample 743 obs from each subset and compare models.  
<br>  


## Bootstrap Resampling Analysis  

*Bins*  
- Original Data set  
- Error Distance present  
- 0-5 km error  
- 0-2 km error  

**Objective**  
1. Re-sample from the three larger data sets (OG, All errors, 0-5 km) at N = 743 (size of 0-2 km)  
2. For each resample, fit a pheno-climatic linear model (for each data set)  
3. Compare the parameter estimates (for climate variables) and confidence intervals based on xxxx samples  
4. Compute significance of differences between estimates among each data set  


**Early by-hand attempt** (Ignore)  
```{r message = FALSE, eval = FALSE}
# Attempt first with one data set

samplelm_params <- matrix(data = NA, nrow = 100, ncol = 8)
colnames(samplelm_params) <-  c("MAT_est", "MAP_est", "MAT_SE", "MAP_SE", "MAT_Clo", "MAT_Cup", "MAP_Cup", "MAP_Clo")


for(i in 1:100){
  #sample
  sample_og <- sample_n(nemo_df2, size = 743, replace = FALSE)

  #modeling
  lm_n <- lm(DOY ~ MAT_100Y + MAP_100Y, data = sample_og)
    
  #store coeffs, std.e [row, col]
  coeffs <- summary(lm_n)$coefficients[c(2:3),1] #2:3 to exclude intercept, inc MAT & MAP
  stde <- summary(lm_n)$coefficients[c(2:3),2]
  
  samplelm_params[i,] <- as.numeric(c(coeffs, stde, 
                            as.numeric(confint(object = lm_n, parm = 'MAT_100Y', level = 0.95)), 
                            as.numeric(confint(object = lm_n, parm = 'MAP_100Y', level = 0.95)))) #Calculate CIs. Must specify vars
  
} 
#for 1:1000, takes about a minute

####
# Significance Tests

# Are parameter estimates significantly different from 0? From each other wrt different error subsets?
#How much do the fits of each sample differ? (variance?)
#Cross-validation: estimate test error? Bootstrapping?

```


*CI type: Norm or BCa (or other e.g. PERC)??*  


### Bootstrap Analysis  
#### MAT & MAP Alone

Goal: Estimate the sampling distribution of a statistic (regression coefficient). The repeated sampling provides the bootstrap mean and SE of the metric. Mimics the sampling of our data from the population. Obtain sampling distribution of the metric.  
Default method for lm regression bootstrap is random-x or case resampling. Bias estimates the bias of the statistic relative to the true population value.  

**R** = 5000 resamples  

Confidence Intervals:  
- Norm type assumes estimates are normally distributed - looks accurate from histograms (below)  
- Alternative: BCA confint method - corrects for bias/skewedness in bootstrapped distribution, uses original estimates unlike norm method  


```{r message = FALSE}
library(boot) #Alternative: try Boot() ftn from `car` package
#Option: Set seed for reproducible result
set.seed(999)
#set.seed(683) seed used for 1/ covariates plot

#In boot() below, each call of the function is without replacement, but replacement = TRUE over multiple samples

#Create function to call in boot()
param_est <- function(df, index){ # df = data, index = # obs to inc [req by boot()]
  
  df_samp <- sample_n(df, size = 743, replace = FALSE) #boot() recomputes the function for each re-sample
  lm_c <- lm(DOY ~ MAT_100Y + MAP_100Y, data = df_samp)
  
  coef(lm_c)
}

#e.g. param_est(nemo_df2, 1:743)


#Save boostrapped data - all observations
boot_df2 <- boot(nemo_df2, param_est, 5000)


#Confidence Intervals
#####
# -- by hand  
#index = 2 for MAT, = 3 for MAP

#boot_df2_ci_MAT <- boot.ci(boot_df2, index = 2, conf = 0.95, type = 'norm') 
#boot_df2_ci_MAP <- boot.ci(boot_df2, index = 3, conf = 0.95, type = 'norm') #low ci is especially negative...
#Alternative: Confint method - car package
#####

boot_df2_ci <- Confint(boot_df2, level = 0.95, type = "norm") #identical to boot.ci() #above#


#Outputs
summary(boot_df2)
boot_df2_ci #confidence intervals do not include bootstrapped estimates...

#Compare to SEs in regular summary. #If SEs are similar b/w boot and original lm outputs, method is appropriate
summary(lm(DOY ~ MAT_100Y + MAP_100Y, data = nemo_df2))


#Plot
plot(boot_df2) #can specify index for different predictors (default = intercept)
hist(boot_df2, ci = 'norm', legend = "separate")

#Distribution of samples appear fairly normally distributed, though confidence intervals (horizontal black bars) are uneven. 
#Observed value of statistic = original estimate (bootMed)


boot_df2_gg <- data.frame(c(boot_df2$t0[2], boot_df2$t0[3]), boot_df2_ci[2:3, 1:2]) #save bootstrapped estimates for MAT, MAP 

boot_df2_ggp <- rownames_to_column(boot_df2_gg) %>% 
  mutate(data = "all")
colnames(boot_df2_ggp) <- c("var", "bootEst", "ci_2.5", "ci_97.5", "data")

```


```{r message = FALSE}
###
# For the subset data:
###

###
#nemo_all_errors
boot_alle <- boot(nemo_all_errors, param_est, 5000)
boot_alle_ci <- Confint(boot_alle, level = 0.95, type = "norm")

#outputs
summary(boot_alle)
boot_alle_ci

#og lm
summary(lm(DOY ~ MAT_100Y + MAP_100Y, data = nemo_all_errors))

plot(boot_alle)
hist(boot_alle, ci = 'norm', legend = "separate") #CIs look super weird... which type to use???

boot_alle_gg <- data.frame(c(boot_alle$t0[2], boot_alle$t0[3]), boot_alle_ci[2:3, 1:2])

boot_alle_ggp <- rownames_to_column(boot_alle_gg) %>% 
  mutate(data = "all_E")
colnames(boot_alle_ggp) <- c("var", "bootEst", "ci_2.5", "ci_97.5", "data")


###
#nemo_e0_5
boot_05 <- boot(nemo_e0_5, param_est, 5000)
boot_05_ci <- Confint(boot_05, level = 0.95, type = "norm")

#outputs
summary(boot_05)
boot_05_ci

#og lm
summary(lm(DOY ~ MAT_100Y + MAP_100Y, data = nemo_e0_5))

plot(boot_05)
hist(boot_05, ci = 'norm', legend = "separate") 

boot_05_gg <- data.frame(c(boot_05$t0[2], boot_05$t0[3]), boot_05_ci[2:3, 1:2])

boot_05_ggp <- rownames_to_column(boot_05_gg) %>% 
  mutate(data = "05km")
colnames(boot_05_ggp) <- c("var", "bootEst", "ci_2.5", "ci_97.5", "data")


###
#nemo_e2 - should have identical results each time #Does not make sense to bootstrap this data set.

#boot_02 <- boot(nemo_e2, param_est, 1000)
#boot.ci(boot_02, index = 2, conf = 0.95, type = 'norm')
#plot(boot_02) - Same data, no distribution of estimates.

#lm sumamry
M100Y_02_lm <- lm(DOY ~ MAT_100Y + MAP_100Y, data = nemo_e2)
summary(M100Y_02_lm) 
#SEs from bootstrap are much much smaller but estimates are identical, as expected

confint(M100Y_02_lm, level = 0.95, type = "norm")

Nboot_02_gg <- data.frame(c(summary(M100Y_02_lm)$coefficient[2], summary(M100Y_02_lm)$coefficient[3]), confint(M100Y_02_lm, level = 0.95, type = "norm")[2:3, 1:2])

Nboot_02_ggp <- rownames_to_column(Nboot_02_gg) %>% 
  mutate(data = "02km")
colnames(Nboot_02_ggp) <-  c("var", "bootEst", "ci_2.5", "ci_97.5", "data")


```


##### Plotting Coefficient Estimates with confidence intervals  
```{r message = FALSE}
##
# Comparing & Plotting bootstrapped parameter estimates
# 95% confidence intervals computed by COnfint (identical to boot.ci) using type = #### (norm)?

#Combine different subset boot estimates 

boots_alldata <- rbind(boot_df2_ggp, boot_alle_ggp, boot_05_ggp, Nboot_02_ggp) %>% 
  mutate(data = factor(data, levels = c("all", "all_E", "05km", "02km")))



ggplot(data = boots_alldata) +
  geom_errorbarh(aes(y = var, xmin = ci_2.5, xmax = ci_97.5, color = data), size = 1) +
  geom_point(aes(x = bootEst, y = var), size = 2) + 
  geom_vline(xintercept = 0, lty = 2) +
  scale_x_continuous(breaks = seq(-10, 10, 1)) +
  scale_color_brewer(palette = "Dark2") +
  facet_wrap(~data, ncol = 1) +
  theme_bw()


```


#### MAT & MAP + Other Covariates  
*Fix confidence interval type*  
```{r message = FALSE}
#including year, elev_m, and long
param_estC <- function(df, index){ # df = data, index = # obs to inc [req by boot()]
  
  df_samp <- sample_n(df, size = 743, replace = FALSE) #boot() recomputes the function for each re-sample
  lm_c <- lm(DOY ~ MAT_100Y + MAP_100Y + year + elev_m + long, data = df_samp)
  
  coef(lm_c)
}

####
#ALL DATA
boot_df2C <- boot(nemo_df2, param_estC, 5000)
boot_df2C_ci <- Confint(boot_df2C, level = 0.95, type = "norm")

#outputs
summary(boot_df2C)
boot_df2C_ci
#og lm
summary(lm(DOY ~ MAT_100Y + MAP_100Y + year + elev_m + long, data = nemo_df2))

plot(boot_df2C) #can specify index for different predictors (default = intercept)
hist(boot_df2C, ci = 'norm', legend = "separate")

#Save to df for plotting
boot_df2C_gg <- data.frame(c(boot_df2C$t0[2], boot_df2C$t0[3]), boot_df2C_ci[2:3, 1:2]) #Just estimates for MAT, MAP 

boot_df2C_ggp <- rownames_to_column(boot_df2C_gg) %>% 
  mutate(data = "all")
colnames(boot_df2C_ggp) <- c("var", "bootEst", "ci_2.5", "ci_97.5", "data")



###
# ALL ERRORS
boot_alleC <- boot(nemo_all_errors, param_estC, 5000)
boot_alleC_ci <- Confint(boot_alleC, level = 0.95, type = "norm")

#outputs
summary(boot_alleC)
boot_alleC_ci

#og lm
summary(lm(DOY ~ MAT_100Y + MAP_100Y + year + elev_m + long, data = nemo_all_errors))

plot(boot_alleC)
hist(boot_alleC, ci = 'norm', legend = "separate") #CIs look super weird... which type to use???

boot_alleC_gg <- data.frame(c(boot_alleC$t0[2], boot_alleC$t0[3]), boot_alleC_ci[2:3, 1:2])

boot_alleC_ggp <- rownames_to_column(boot_alleC_gg) %>% 
  mutate(data = "all_E")
colnames(boot_alleC_ggp) <- c("var", "bootEst", "ci_2.5", "ci_97.5", "data")


###
# 0-5 KM
boot_05C <- boot(nemo_e0_5, param_estC, 5000)
boot_05C_ci <- Confint(boot_05C, level = 0.95, type = "norm")

#outputs
summary(boot_05C)
boot_05C_ci

#og lm
summary(lm(DOY ~ MAT_100Y + MAP_100Y + year + elev_m + long, data = nemo_e0_5))

plot(boot_05C)
hist(boot_05C, ci = 'norm', legend = "separate") 

boot_05C_gg <- data.frame(c(boot_05C$t0[2], boot_05C$t0[3]), boot_05C_ci[2:3, 1:2])

boot_05C_ggp <- rownames_to_column(boot_05C_gg) %>% 
  mutate(data = "05km")
colnames(boot_05C_ggp) <- c("var", "bootEst", "ci_2.5", "ci_97.5", "data")


###
# 0-2 KM (no bootstrap)

#og lm
M100Y_02C_lm <- lm(DOY ~ MAT_100Y + MAP_100Y + year + elev_m + long, data = nemo_e2)
summary(M100Y_02C_lm)

confint(M100Y_02C_lm, level = 0.95, type = "norm")

Nboot_02C_gg <- data.frame(c(summary(M100Y_02C_lm)$coefficient[2], summary(M100Y_02C_lm)$coefficient[3]), confint(M100Y_02C_lm, level = 0.95, type = "norm")[2:3, 1:2])

Nboot_02C_ggp <- rownames_to_column(Nboot_02C_gg) %>% 
  mutate(data = "02km")
colnames(Nboot_02C_ggp) <-  c("var", "bootEst", "ci_2.5", "ci_97.5", "data")
```


```{r message = FALSE}
##GGPLOT of Bootstrapped models + covariates
boots_alldataC <- rbind(boot_df2C_ggp, boot_alleC_ggp, boot_05C_ggp, Nboot_02C_ggp) %>% 
  mutate(data = factor(data, levels = c("all", "all_E", "05km", "02km")))

## Plot with SE instead??
##Show coeffs for year, elev, long??

ggplot(data = boots_alldataC) +
  geom_errorbarh(aes(y = var, xmin = ci_2.5, xmax = ci_97.5, color = data), size = 1) +
  geom_point(aes(x = bootEst, y = var), size = 2) + 
  geom_vline(xintercept = 0, lty = 2) +
  scale_x_continuous(breaks = seq(-10, 10, 1)) +
  scale_color_brewer(palette = "Dark2") +
  facet_wrap(~data, ncol = 1) +
  theme_bw()





```



---  



## Randomly simulated coordinates (lat/long) by a set error distance  

How does varying point coordinates by different error distances affect pheno-climatic models?  

Steps:  
1. Assign each record (0-2 km set) four sets of new coordinates, each dispersed in a random direction from the original  
  - 2 km away  
  - 5 km away  
  - 15 km away  
  - 25 km away  
2. Obtain climate data for each new coordinate set  
3. Compare models of the original 2 km data set with those of the 4 new data sets  
4. Replication (5x)  

<br>  

Determining new coordinates based on km will depend on the present latitude and longitude of a collection. Simulations here are based off a subset of the original data for which confidence in specimen collection locations is high (0-2 km) so that deviations in the parameter estimates and $R^2$ values of models from simulated data can be attributed to effects of real differences in collection uncertainty AND locations. Use the WGS84 ellipsoid (the datum used for the majority of records; some NAD83 and NAD27 [*calculate % in 0-2km data*]) to calculate new decimal degrees based on some km deviation at each record. 

"geosphere" package -> `destPoint()` function computes a new coordinate point (WGS84) when given a start point, initial bearing, and distance.  


### Assign new coordinates  
#### SIMULTATIONS ONLY for HIGH-CONFIDENCE COLLECTIONS (0-2 KM ERROR DISTANCE)  

```{r}
library(geosphere)
nemo_r_2 <- nemo_e2 %>% 
  select(specimen_number:mature_5)

#destPoint from geosphere package - e.g.
destPoint(p = c(-120.0312, 37.47905), b = 45, d = 2000) #default WGS84
#Seems pretty accurate!!! (Compared start and end points in Google maps)


##
### Goal: apply destPoint() to all existing lat/long to get new lat/long, each with *different* random bearing

#Basic for loop
  long_n1 <- rep(NA, nrow(nemo_r_2))
  lat_n1 <- rep(NA, nrow(nemo_r_2))
  
for(i in 1:length(nemo_r_2$lat)){
  
  
  latlong_n <- destPoint(p = c(nemo_r_2$long[i], nemo_r_2$lat[i]), b = sample(0:360, 1), d = 1000)
  
  long_n1[i] <-  latlong_n[1]
  lat_n1[i] <-  latlong_n[2]
   
}


#######
# 2 km error new coords
#######
#Simulations + for loop

  
sim_list_2ka <- list()

for(x in 1:10){ #10 reps
  
  long_n1 <- rep(NA,nrow(nemo_r_2))
  lat_n1 <- rep(NA, nrow(nemo_r_2))

  
for(i in 1:length(nemo_r_2$lat)){
  
  latlong_n <- destPoint(p = c(nemo_r_2$long[i], nemo_r_2$lat[i]), b = sample(0:360, 1), d = runif(1, 0, 2000))
  
  long_n1[i] <-  latlong_n[1]
  lat_n1[i] <-  latlong_n[2]
   
}
  
  sim_list_2ka[[x]] <- cbind(nemo_r_2$specimen_number, long_n1, lat_n1)
  colnames(sim_list_2ka[[x]]) <- c("specimen_number", "long_n2k", "lat_n2k")
  
  print(x)
  
}
  
  
#Rbind all list elements

  
#Using bind_rows()
#sims_all_2ka <- bind_rows(sim_list_2ka[[1:10]])


#using reduce() 
sims_all_2ka <- as.data.frame(reduce(sim_list_2ka, rbind)) %>% 
  mutate(replicate = c(rep("rep1", times = 743), rep("rep2", times = 743), rep("rep3", times = 743), rep("rep4", times = 743),rep("rep5", times = 743),rep("rep6", times = 743),rep("rep7", times = 743), rep("rep8", times = 743), rep("rep9", times = 743), rep("rep10", times = 743))) %>% 
  mutate(long_n2k = as.numeric(long_n2k), lat_n2k = as.numeric(lat_n2k))
```

##### Add elevation to records (optional for ClimateNA)  
**Very time-consuming!!!**  
```{r message = FALSE, eval = FALSE}
#Add elevation
library(elevatr)
prj_dd <- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs" #Define parameters for get_elev_point()


sims_all_2kaE$elev_m_n <- get_elev_point(sims_all_2ka[,2:3], prj = prj_dd, src = "epqs")$elevation #store only elev, function creates new df...


sims_all_2kaE2 <- sims_all_2ka %>% 
  mutate(elev_m_n = sims_all_2kaE[[1]]) 


#save as CSV before something fucks up and I have to rerun the 3h elev grab code
write_csv(sims_all_2kaE2, here::here("analyses", "new_coords", "sims_2ka.csv"))


#E.g. 2, 5, 15, 25 km coords all in same csv...?
```


```{r}
#Read CSV - fix negative elevations to be 0
```


**Standardize & Save CSV for ClimateNA data extraction**  
Columns: ID1, ID2, lat, long,	el  

```{r message = FALSE, eval = FALSE}
# 2 km simulated coordinates 
#Maybe have ID2 = replicate identifier?
#sims_2ka <- 



```
*NOTE*: If extraction fails at first, **clear** all cells below final rows of standardized CSV!  

*Calculate* Difference in (1) elevation, (2) MAT and MAP between original and simulated coordinates  
- Determine if differences in elev or climate relate to differences in model results!  
```{r}

```

```{r eval = FALSE, message = FALSE}
#DEFUNCT/FAILED ANALYSES
library(elevatr) #must have package rgdal installed!
#Get elevation for new coords as well
prj_dd <- "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs" #Define parameters for get_elev_point() ##MAKE DATUM SPECIFIC TO RECORD???

for(x in 1:length(sim_list_2ka)){
  
elev_n1 <- rep(NA, nrow(nemo_r_2))

for(i in 1:length(nemo_r_2$lat)){

elev_n1[i] <- get_elev_point(as.numeric(sim_list_2ka[[x]][,2:3]), prj = prj_dd, src = "epqs")

}

sim_list_2ka_e[[x]] <- cbind(sim_list_2ka, elev_n1)

}

######Unable to apply for loop using get_elev_point to list - too complicated


#Tadeo's randCoord function
#randCoord(x = c(-120.66, -120), y = c(34.66, 37), d_min = 1.5, d_max = 2.5)

#randCoord(x = nemo_r_2$long, y = nemo_r_2$lat, d_min = 1.5, d_max = 2.5)

# apply() functions approach


#destPoint alone
nemo_ncoords_2km <- nemo_r_2 %>% 
  mutate(long_n1 = sapply(X = c(long, lat), FUN = destPoint(long, lat, b = sample(0:360, 1), d = 2000)))


#getLatLong_r function
nemo_ncoords_2km <- nemo_r_2 %>% 
  mutate(longlat_n1 = sapply(X = c(long, lat, d = 2000), FUN = getLatLong_r(lat = lat, long = long)))

#destPoint(p = c(long, lat), b = sample(0:360, 1), d = 2000)[,1]) #for loop or tapply

nemo_ncoords_2km <- nemo_r_2 %>% 
  mutate(long_n1 = NA, lat_n1 = NA)


```





